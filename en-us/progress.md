# Study Progress

## Week 1: Practical Fundamentals of LLMs and Embeddings

### Day 1: LLM Theory
- [ ] Read about LLMs (AWS Guide)
- [ ] Read The Illustrated Transformer (50%)
- [ ] Summarize in 3 paragraphs
- [ ] List 5 practical applications

### Day 2: Embedding Theory  
- [ ] Read about embeddings (OpenAI)
- [ ] Read Word2Vec Explained
- [ ] Create mind map of types
- [ ] Think of 3 personal use cases

### Day 3: Setup and First Code
- [ ] Configure Python environment
- [ ] Create example_01_basic.py
- [ ] Test with 3-5 sentences
- [ ] Document observations

### Day 4: Similarity Comparison
- [ ] Create example_02_similarity.py
- [ ] Test similar vs different pairs
- [ ] Create results table
- [ ] Document insights

### Day 5: Model Comparison
- [ ] Create example_03_model_comparison.py
- [ ] Test 3 different models
- [ ] Compare speed vs quality
- [ ] Trade-offs analysis

### Day 6: Visualization
- [ ] Create example_04_visualization.py
- [ ] Implement t-SNE/UMAP
- [ ] Plot embeddings
- [ ] Interpret clusters

### Day 7: Final Mini-Project
- [ ] Create semantic_search_mini_project.py
- [ ] Dataset of 20-30 sentences
- [ ] Search interface
- [ ] Documented README

---

## Week 2: Vector Databases in Practice

### Day 1: Vector Database Theory
- [ ] Read about vector databases and use cases
- [ ] Compare ChromaDB, Pinecone, Weaviate, Qdrant
- [ ] Understand architectures and trade-offs

### Day 2: ChromaDB Setup
- [ ] Install and configure ChromaDB
- [ ] Create first collection
- [ ] Index basic embeddings

### Day 3: CRUD Operations
- [ ] Implement document insertion
- [ ] Similarity search
- [ ] Update and deletion

### Day 4: Optimization and Performance
- [ ] Test different configurations
- [ ] Measure query performance
- [ ] Optimize indexes

### Day 5: Application Integration
- [ ] REST API for vector database
- [ ] Simple web interface
- [ ] Integration tests

### Day 6: Framework Comparison
- [ ] Test FAISS alternative
- [ ] Compare performance and ease of use
- [ ] Document choices

### Day 7: Final Mini-Project
- [ ] Complete semantic search system
- [ ] Functional web interface
- [ ] Documentation and tests

---

## Week 3: Retrieval-Augmented Generation (RAG)

### Day 1: RAG Theory and Architecture
- [ ] Understand RAG concept
- [ ] Map components: Retrieval → Augmentation → Generation
- [ ] Use cases vs fine-tuning

### Day 2: LangChain Fundamentals
- [ ] Setup LangChain
- [ ] Implement basic RAG pipeline
- [ ] Document loaders and text splitters

### Day 3: LlamaIndex Fundamentals
- [ ] Setup LlamaIndex
- [ ] Compare with LangChain
- [ ] Implement alternative RAG

### Day 4: Chunking Strategies
- [ ] Test different chunking strategies
- [ ] Optimize for retrieval quality
- [ ] Best practices

### Day 5: Prompt Engineering for RAG
- [ ] Optimize prompts for RAG
- [ ] Test different templates
- [ ] Evaluate response quality

### Day 6: Evaluation and Metrics
- [ ] Implement evaluation metrics
- [ ] Create test dataset
- [ ] Quality dashboard

### Day 7: Final Mini-Project
- [ ] Complete Q&A system
- [ ] Streamlit interface
- [ ] Automated evaluation

---

## Week 4: Model Context Protocol (MCP) and Interoperability

### Day 1: Introduction to MCP
- [ ] Understand MCP concept
- [ ] Advantages for interoperability
- [ ] Practical use cases

### Day 2: Architecture and Components
- [ ] Study MCP specification
- [ ] Understand components: Context, Resources, Tools
- [ ] Communication flow

### Day 3: First MCP Client
- [ ] Implement basic MCP client
- [ ] Connect to demo server
- [ ] Test communication

### Day 4: MCP Server
- [ ] Implement own server
- [ ] Expose data via MCP
- [ ] Test client-server

### Day 5: LangChain Integration
- [ ] Integrate MCP with LangChain
- [ ] Compare with traditional tools
- [ ] Standardization advantages

### Day 6: Multi-Framework
- [ ] Connect LangChain + LlamaIndex via MCP
- [ ] Demonstrate interoperability
- [ ] Measure overhead

### Day 7: Final Mini-Project
- [ ] Multi-service ecosystem
- [ ] Communication via MCP
- [ ] Monitoring dashboard

---

## Week 5: Memory, Context and Persistence

### Day 1: AI Memory Theory
- [ ] Types of memory: short vs long term
- [ ] Importance for agents
- [ ] Implementation strategies

### Day 2: Memory in LangChain
- [ ] Implement different memory types
- [ ] ConversationBufferMemory vs VectorMemory
- [ ] Trade-offs of each approach

### Day 3: Persistence with Vector Databases
- [ ] Implement memory with ChromaDB
- [ ] Semantic search in history
- [ ] Indexing strategies

### Day 4: Hierarchical Memory
- [ ] Multi-layer system
- [ ] Buffer + session + long term
- [ ] Consolidation algorithms

### Day 5: User Profiles
- [ ] Personalized profile system
- [ ] Preference extraction
- [ ] Privacy and security

### Day 6: Memory with LlamaIndex
- [ ] Implement with LlamaIndex
- [ ] Compare approaches
- [ ] Integration with indexes

### Day 7: Final Mini-Project
- [ ] Chatbot with advanced memory
- [ ] Streamlit interface
- [ ] Memory dashboard

---

## Week 6: Fine Tuning and LoRA

### Day 1: Fine-Tuning Theory
- [ ] Fine-tuning vs RAG vs Prompt Engineering
- [ ] When to use each approach
- [ ] Costs and benefits

### Day 2: Introduction to LoRA
- [ ] Understand LoRA technique
- [ ] Mathematics: Low-Rank Adaptation
- [ ] Advantages vs full fine-tuning

### Day 3: First Fine-Tuning
- [ ] Setup environment: transformers, peft
- [ ] Fine-tuning with small model
- [ ] Compare results

### Day 4: LoRA with PEFT
- [ ] Implement LoRA
- [ ] Configure hyperparameters
- [ ] Optimize memory usage

### Day 5: Quantization
- [ ] 8-bit and 4-bit quantization
- [ ] QLoRA implementation
- [ ] Performance vs quality trade-offs

### Day 6: Dataset and Evaluation
- [ ] Prepare own datasets
- [ ] Evaluation metrics
- [ ] Complete pipeline

### Day 7: Final Mini-Project
- [ ] Specialized fine-tuning
- [ ] Specific use case
- [ ] Demonstration interface

---

## Week 7: AI Agents and Orchestration

### Day 1: Agent Theory
- [ ] Types of agents: Reactive, Deliberative
- [ ] Agents vs chatbots
- [ ] Taxonomy and applications

### Day 2: LangChain Agents
- [ ] First functional agent
- [ ] Tools: Calculator, Search, Custom
- [ ] Reasoning and tool selection

### Day 3: Custom Tools
- [ ] Create personalized tools
- [ ] File operations, API calls
- [ ] Design best practices

### Day 4: Introduction to CrewAI
- [ ] Setup CrewAI
- [ ] Collaborative agents
- [ ] Compare with LangChain

### Day 5: Agents with Memory
- [ ] Integrate memory with agents
- [ ] Action history
- [ ] Preference learning

### Day 6: Debugging and Observability
- [ ] Logging system
- [ ] Performance metrics
- [ ] Monitoring dashboard

### Day 7: Final Mini-Project
- [ ] Autonomous personal assistant
- [ ] Multiple tools
- [ ] Complete web interface

---

## Week 8: Advanced Orchestration and Multi-Agents

### Day 1: Multi-Agent Theory
- [ ] Multi-agent systems
- [ ] Communication patterns
- [ ] Coordination challenges

### Day 2: AutoGen Framework
- [ ] Setup AutoGen
- [ ] Agent conversation
- [ ] Communication patterns

### Day 3: Advanced CrewAI
- [ ] Complex workflows
- [ ] Agent dependencies
- [ ] Collaboration optimization

### Day 4: Communication Protocols
- [ ] Message passing
- [ ] Shared memory
- [ ] Event-driven communication

### Day 5: LangGraph Workflows
- [ ] Graph-based workflows
- [ ] Decision nodes and routing
- [ ] Execution visualization

### Day 6: Multi-Agent Monitoring
- [ ] Distributed metrics
- [ ] Real-time dashboard
- [ ] Troubleshooting

### Day 7: Final Mini-Project
- [ ] Data analysis system
- [ ] Multi-agent pipeline
- [ ] Complete orchestration

---

## Week 9: Deploy, Observability and Evaluation

### Day 1: Deploy Strategies
- [ ] REST API vs serverless vs edge
- [ ] Trade-offs of each approach
- [ ] Choice by use case

### Day 2: API with FastAPI
- [ ] Production-ready API
- [ ] Robust endpoints
- [ ] Middleware and documentation

### Day 3: Containerization
- [ ] Optimized Docker
- [ ] Multi-stage builds
- [ ] docker-compose stack

### Day 4: Observability
- [ ] Performance metrics
- [ ] Prometheus + Grafana
- [ ] Automatic alerts

### Day 5: Continuous Evaluation
- [ ] A/B testing
- [ ] Data drift detection
- [ ] Automatic retraining

### Day 6: Optimization and Scale
- [ ] Caching and batch inference
- [ ] Load balancing
- [ ] Auto-scaling

### Day 7: Final Mini-Project
- [ ] Complete ML platform
- [ ] Cloud deployment
- [ ] Production monitoring

---

## Week 10: Advanced Topics and Multi-modality

### Day 1: Multi-modality Introduction
- [ ] Vision-language models
- [ ] Modalities: text, image, audio
- [ ] Fusion architectures

### Day 2: Vision-Language Models
- [ ] GPT-4V, LLaVA, CLIP
- [ ] Image captioning
- [ ] Visual question answering

### Day 3: Multi-modal Generation
- [ ] Text to image
- [ ] Complex workflows
- [ ] Quality evaluation

### Day 4: Security and Guardrails
- [ ] Content filtering
- [ ] Toxicity detection
- [ ] Security framework

### Day 5: Prompt Injection
- [ ] Attack types
- [ ] Defenses and mitigations
- [ ] Red team testing

### Day 6: Ethical Evaluation
- [ ] Bias metrics
- [ ] Fairness and transparency
- [ ] Ethical pipeline

### Day 7: Final Mini-Project
- [ ] Secure multi-modal assistant
- [ ] Guardrails system
- [ ] Complete audit

---

## General Notes
- **Start date:** ___________
- **Difficulties encountered:**
- **Important learnings:**
- **Ideas for future projects:**
- **Favorite technologies:**
- **Next steps after the 10 weeks:** 